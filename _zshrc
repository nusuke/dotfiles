# ctrl e ctrl a など
bindkey -e
alias zshrc='vim ~/.zshrc'
alias zshrcs='source ~/.zshrc'
alias gitconfig='vim ~/.gitconfig'
alias sshconfig='vim ~/.ssh/config'
alias vimrc='vim ~/.vimrc'
alias dotfiles='cd ~/dotfiles'
alias desktop='cd ~/desktop'
alias lzd='lazydocker'
alias idea='/Applications/IntelliJ\ IDEA\ CE.app/Contents/MacOS/idea'
alias dcd='docker compose down'
alias dcu='docker compose up'
alias dcud='docker compose up -d'

function fm(){
 git fetch -p
 current_branch=$(git branch --show-current)
 git merge --ff-only origin/$current_branch
}
alias ghpr='gh pr create --web'


#Java
export PATH=$PATH:/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home/bin
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home

# zsh
autoload -U compinit
compinit

autoload -Uz colors
colors

# 履歴ファイルの保存先
export HISTFILE=${HOME}/.zhistory
# メモリに保存される履歴の件数
export HISTSIZE=1000
# 履歴ファイルに保存される履歴の件数
export SAVEHIST=100000
# 重複を記録しない
setopt hist_ignore_dups
# historyを共有
setopt share_history
# ヒストリに追加されるコマンド行が古いものと同じなら古いものを削除
setopt hist_ignore_all_dups
# スペースで始まるコマンド行はヒストリリストから削除
setopt hist_ignore_space
# ヒストリを呼び出してから実行する間に一旦編集可能
setopt hist_verify
# 余分な空白は詰めて記録
setopt hist_reduce_blanks
# 古いコマンドと同じものは無視
setopt hist_save_no_dups
# historyコマンドは履歴に登録しない
setopt hist_no_store
# 補完時にヒストリを自動的に展開
setopt hist_expand
# 履歴をインクリメンタルに追加
setopt inc_append_history
# インクリメンタルからの検索
#bindkey "^R" history-incremental-search-backward
#bindkey "^S" history-incremental-search-forward
# 全件取得
function history-all { history -E 1 }

ISTIGNORE='fg:fg *bg:bg *histroy:history *'

#Directory color
#alias ls='ls -FG'
export LSCOLORS=cafxcxdxbxegedabagacad
alias ls='eza'
alias mkdir='mkdir -p'
alias cat='bat'

# fzf
export FZF_DEFAULT_OPTS="--height 50% --layout=reverse --border --inline-info --preview 'bat  --color=always --style=header,grid --line-range :100 {}'"

function bats() {
  $(bat $1 | fzf --preview "{}")
}

alias fr='cd ~/src/$(ghq list | fzf --tmux --reverse +m --preview "cat ~/{}/README.md")'
gd() {
  files=$(git diff --name-only | fzf --preview 'git diff --color {}') &&
  vim $files
}
fvim() {
  files=$(git ls-files) &&
  selected_files=$(echo "$files" | fzf -m --preview "bat  --color=always --style=header,grid --line-range :100 {}") &&
  vim $selected_files
}
# git checkout branchをfzfで選択
alias fb='git checkout $(git branch -a | tr -d " " |fzf --prompt "CHECKOUT BRANCH>" --preview "git log --color=always {}" | head -n 1 | sed -e "s/^\*\s*//g" | perl -pe "s/remotes\/origin\///g")'
alias fbb='git reflog | grep "checkout: moving from" | sed -E "s/.*moving from [^ ]* to ([^ ]*).*/\1/" | awk '\''!seen[$0]++'\'' | fzf --preview "git sw {}"'

# PROMPT
PROMPT="%{${fg[blue]}%}[%~]%{${reset_color}%}"

autoload -Uz vcs_info
setopt prompt_subst
zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:git:*' stagedstr "%F{yellow}!"
zstyle ':vcs_info:git:*' unstagedstr "%F{red}+"
zstyle ':vcs_info:*' formats "%F{green}%c%u[%b]%f"
zstyle ':vcs_info:*' actionformats '[%b|%a]'
precmd () {
  if [ $? -eq 0 ] ; then
    finish_code=0
  else
    finish_code="%{${fg[red]}%}'${$?}'%{${reset_color}%}"
  fi
  vcs_info

  # worktree検出
  local git_dir=$(git rev-parse --git-dir 2>/dev/null)
  if [[ "$git_dir" == *"/worktrees/"* ]]; then
    local wt_name=$(basename "$git_dir")
    worktree_info="%{${fg[magenta]}%}[wt:${wt_name}]%{${reset_color}%}"
  else
    worktree_info=""
  fi
}

PROMPT='${finish_code};'$PROMPT'${vcs_info_msg_0_}${worktree_info}'
#RPROMPT=$RPROMPT'${vcs_info_msg_0_}'
export VOLTA_HOME="$HOME/.volta"
export PATH="$VOLTA_HOME/bin:$PATH"


# git worktree
function wth() {
  echo "git worktree commands:"
  echo "  wtl                          - worktree一覧表示"
  echo "  wtp                          - 不要なworktree情報を整理(prune)"
  echo "  wta <branch> [path]          - 既存ブランチでworktree作成"
  echo "  wtan <branch> [base] [path]  - 新規ブランチでworktree作成"
  echo "  fwt                          - fzfでworktreeを選択して移動"
  echo "  fwta                         - fzfでブランチを選択してworktree作成"
  echo "  wtr                          - fzfでworktreeを選択して削除"
  echo "  wth                          - このヘルプを表示"
}
alias wtl='git worktree list'
alias wtp='git worktree prune'

# worktreeを作成（既存ブランチ）: wta <branch-name> [path]
function wta() {
  local branch=$1
  local repo=$(basename "$(git rev-parse --show-toplevel)")
  local wt_path=${2:-"../${repo}-${branch}"}
  git worktree add "$wt_path" "$branch"
}

# worktreeを作成（新規ブランチ）: wtan <new-branch-name> [base-branch] [path]
function wtan() {
  local branch=$1
  local base=${2:-"HEAD"}
  local repo=$(basename "$(git rev-parse --show-toplevel)")
  local wt_path=${3:-"../${repo}-${branch}"}
  git worktree add -b "$branch" "$wt_path" "$base"
}

# fzfでworktreeを選択して移動
function fwt() {
  local selected=$(git worktree list | fzf --prompt "WORKTREE>" --preview "ls -la {1}" | awk '{print $1}')
  if [[ -n "$selected" ]]; then
    cd "$selected"
  fi
}

# fzfでworktreeを選択して削除
function wtr() {
  local selected=$(git worktree list | fzf --prompt "REMOVE WORKTREE>" --preview "ls -la {1}" | awk '{print $1}')
  if [[ -n "$selected" ]]; then
    echo "Removing worktree: $selected"
    git worktree remove "$selected"
  fi
}

# fzfでブランチを選択してworktreeを作成
function fwta() {
  local branch=$(git branch -a | tr -d " " | sed 's/^\*//g' | sed 's/remotes\/origin\///g' | sort -u | fzf --prompt "SELECT BRANCH>")
  if [[ -n "$branch" ]]; then
    local repo=$(basename "$(git rev-parse --show-toplevel)")
    local wt_path="../${repo}-${branch}"
    echo "Creating worktree: $wt_path for branch: $branch"
    git worktree add "$wt_path" "$branch"
  fi
}

#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
